#!/usr/bin/env ruby

require 'inifile'
require 'csv'

require './ui_helpers.rb'
require './timer_process.rb'
require './sound.rb'

#require './ui_screen_lcd.rb'
require './ui_screen_console.rb'

#require './ui_input_gpiobuttons.rb'
require './ui_input_console.rb'

#require './ui_speech_cerevoice.rb'
require './ui_speech_console.rb'

require './loader_files.rb'

class PowerException < RuntimeError
end

def secs_to_ms(secs)
  sprintf("%d:%02d", secs / 60, secs % 60)
end

def secs_to_ms_words(secs)
  s = "s"
  if(secs > 60 && secs % 60 > 0) then
    s = "" if secs / 60 == 1
    sprintf("%d minute#{s} and %2d seconds", secs / 60, secs % 60)
  elsif(secs > 60 && secs % 60 == 0) then
    s = "" if secs / 60 == 1
    sprintf("%d minute#{s}", secs / 60)
  else
    s = "" if secs == 1
    sprintf("%2d second#{s}", secs)
  end
end

def wait_for_select(lcd)
  until(PiButtons::wait_for_button(lcd) == :select) do
    sleep 0.1
  end
end

def handle_sleep(lcd)
  select_gpio = PiPiper::Pin.new   :pin => 26, :pull => :up
  next_gpio = PiPiper::Pin.new     :pin => 20, :pull => :up
  power_gpio = PiPiper::Pin.new    :pin => 21, :pull => :up
  lcd.clear
  lcd.message "  System Off  "
  lcd.backlight Adafruit::LCD::Char16x2::OFF
  while(power_gpio.read != 0) do
    if(next_gpio.read == 0 && select_gpio.read == 0) then
      lcd.clear
      lcd.backlight Adafruit::LCD::Char16x2::WHITE
      lcd.message "Shutting down..."
      system "/sbin/shutdown -h now"
    end
    sleep 0.25
  end
  lcd.backlight Adafruit::LCD::Char16x2::RED
  lcd.clear
end

def run_process(screen, input, speech_engine, process)
  process.each_step do |step|
    if(step.tweakable) then
      tweak_yn = LCDYesNo.new(screen, input, "Tweak #{step.short_name} time?")
      next if !tweak_yn.get_answer
      sec_adjust = LCDAdjustTime.new(screen, input, step.short_name, step.seconds, 15)
      step.seconds = sec_adjust.get_value
    end
  end 

  step_idx = 0
  while(step_idx < process.steps.length-1) do
    step = process[step_idx]
    if(step.backlight == :half or step.backlight == :off or (step_idx > 0 and process[step_idx-1].backlight == :off)) then
      screen.background_colour :off
    else
      screen.background_colour :red
    end
    process_info = "#{process.name} #{step.short_name}".center(16)
    screen.clear
    screen.write "#{process_info}\n Ready to Start "
    speech_engine.say step.phrases[:ready_to_start]
    select_pressed = false
    case input.wait_for_button
      when :select
        select_pressed = true
      when :next
        next if step_idx == process.steps.length-1
        step_idx += 1
      when :previous
        next if step_idx == 0
        step_idx -= 1
    end
    redo if !select_pressed
    Sound.play "start"

    step_aborted = step.run do |secs_left|
      process_time = "T:#{secs_to_ms(step.seconds)} R:#{secs_to_ms(secs_left)}".center(16)
      screen.home
      screen.write "#{process_info}\n#{process_time}"
      if(input.is_select_pressed?) then
        Sound.play "abort"
        speech_engine.say_wait step.phrases[:aborted]
        break true
      end
      if(step.backlight == :half && (step.seconds / 2).to_i == secs_left.to_i) then
        screen.background_colour :red
        speech_engine.say step.phrases[:light_safe]
      elsif((secs_left % 30 == 0 and secs_left > 5) or secs_left == 5) then
        speech_engine.say sprintf(step.phrases[:time_left], secs_to_ms_words(secs_left)) if (secs_left % 30 == 0 and secs_left > 5) or secs_left == 5
      elsif(secs_left % 5 == 0) then
        Sound.play "click"
      end
    end
    redo if step_aborted
    
    Sound.play_wait "stop"
    speech_engine.say_wait step.phrases[:complete]
    step_idx += 1
  end
end

def render_process(screen, speech, process)
  return if File.exist? "processes/#{process.name}.rendered"
  screen.clear
  screen.write "Wait, rendering."
  process.steps.each do |step|
    step.phrases.each do |phrase_key, phrase|
      if(phrase.include? "%s") then
        # phrase includes time left, so cycle through all the times this step needs
        secs_to_prepare = step.seconds
        secs_to_prepare += 180 if step.tweakable # assume the user might add up to 3 minutes
        (0..secs_to_prepare).step(30).each do |secs_left|
          speech.prepare sprintf(phrase, secs_to_ms_words(secs_left))
        end
      else
        speech.prepare phrase
      end
    end
  end
  File.open("processes/#{process.name}.rendered", "w") {}
end

cfg = IniFile.load("/etc/darkroomtimer.conf")
screen = TimerUI::Screen.new
input = TimerUI::Input.new
speech = TimerUI::Speech.new(cfg['Cerevoice']['UserID'], cfg['Cerevoice']['Password'])

while(true) do
  begin
    screen.background_colour :red
    process = ProcessLoader::load_process(screen, input)
    render_process screen, speech, process
    run_process screen, input, speech, process
#  rescue PowerException
#    handle_sleep(screen)
  end
end

